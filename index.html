<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Curler</title>
	<link rel="stylesheet" href="index.css">
</head>

<body>
	<header>
		<h1>Curler</h1>
	</header>

	<div class="container">
		<div class="panel">
			<div class="panel-header">
				<h2>cURL Request</h2>
				<div class="panel-header-actions">
					<label class="cors-toggle" title="Route requests through a CORS proxy to avoid cross-origin errors">
						<input type="checkbox" id="corsToggle"> CORS Proxy
					</label>
					<button id="sendBtn">Send Request</button>
				</div>
			</div>

			<textarea id="curlInput" placeholder="Paste your cURL command here (bash, PowerShell, or cmd)..."></textarea>
		</div>

	<div class="panel">
		<div class="panel-header">
			<h2>Response</h2>
			<button id="clearBtn">Clear</button>
		</div>
		<div class="search-container">
			<input type="text" id="searchInput" placeholder="Search in response...">
			<span class="search-info" id="searchInfo"></span>
		</div>
		<div class="output-container">
			<div id="outputHighlight"></div>
			<textarea id="output" class="output" readonly placeholder="Response will appear here..."></textarea>
		</div>
		<div class="status" id="status"></div>
	</div>
	</div>

	<script>
		const curlInput = document.getElementById('curlInput');
		const output = document.getElementById('output');
		const outputHighlight = document.getElementById('outputHighlight');
		const sendBtn = document.getElementById('sendBtn');
		const clearBtn = document.getElementById('clearBtn');
		const status = document.getElementById('status');
		const searchInput = document.getElementById('searchInput');
		const searchInfo = document.getElementById('searchInfo');

		let searchMatches = [];
		let currentMatchIndex = -1;

		// Sync textarea scroll with highlight overlay
		output.addEventListener('scroll', () => {
			outputHighlight.scrollTop = output.scrollTop;
			outputHighlight.scrollLeft = output.scrollLeft;
		});

		function formatSize(bytes) {
			if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
			if (bytes >= 1024) return (bytes / 1024).toFixed(2) + ' kB';
			return bytes + ' bytes';
		}

		function parsePowerShellNative(cmd) {
			const request = {
				method: 'GET',
				headers: {},
				body: null,
				url: ''
			};

			// Extract -Uri (handle quoted URLs that may contain special chars)
			const uriMatch = cmd.match(/-Uri\s+["']([^"']+)["']/i) ||
				cmd.match(/-Uri\s+([^\s]+)/i);
			if (uriMatch) {
				// Clean PowerShell backtick escapes from URL (e.g., `$ -> $)
				request.url = uriMatch[1].replace(/`(.)/g, '$1');
			}

			// Extract -Method
			const methodMatch = cmd.match(/-Method\s+['"]?(\w+)['"]?/i);
			if (methodMatch) request.method = methodMatch[1].toUpperCase();

			// Extract -ContentType
			const ctMatch = cmd.match(/-ContentType\s+['"]([^'"]+)['"]/i);
			if (ctMatch) request.headers['Content-Type'] = ctMatch[1];

			// Extract -Headers @{ ... } — supports both semicolon and newline separated pairs
			const headersMatch = cmd.match(/-Headers\s+@\{([\s\S]*?)\}/i);
			if (headersMatch) {
				// Split on semicolons or newlines
				const lines = headersMatch[1].split(/[;\r\n]+/);
				for (const line of lines) {
					const kv = line.match(/["']?([^"'=]+?)["']?\s*=\s*["'](.+?)["']\s*$/);
					if (kv) {
						const key = kv[1].trim();
						// Clean PowerShell backtick escapes from values (e.g., `" -> ")
						const value = kv[2].replace(/`(.)/g, '$1');
						request.headers[key] = value;
					}
				}
			}

			// Extract -Body
			const bodyMatch = cmd.match(/-Body\s+['"](.+?)['"]/s) ||
				cmd.match(/-Body\s+@'[\r\n]+([\s\S]+?)[\r\n]+'@/);
			if (bodyMatch) request.body = bodyMatch[1];

			return request;
		}

		function parseCurl(curlCommand) {
			const request = {
				method: 'GET',
				headers: {},
				body: null,
				url: ''
			};

			// Strip PowerShell variable assignments preceding the command (e.g., $session = New-Object ...)
			let cmd = curlCommand.replace(/^\$\w+\s*=\s*[^\r\n]+[\r\n]+/gm, '').trim();

			// Remove PowerShell backtick line continuations, but NOT backtick escapes inside strings
			// Only strip a backtick immediately followed by a newline
			cmd = cmd
				.replace(/`\r?\n/g, ' ')   // PowerShell backtick line continuations
				.replace(/\^\r?\n/g, ' ')  // cmd caret continuations
				.replace(/\\\r?\n/g, ' ')  // Bash backslash continuations
				.trim();

			// Detect PowerShell native commands (Invoke-WebRequest, Invoke-RestMethod, iwr, irm)
			// They may appear after stripping variable lines, or with flags like -UseBasicParsing first
			if (/(?:Invoke-(?:WebRequest|RestMethod)|iwr|irm)\s/i.test(cmd)) {
				return parsePowerShellNative(cmd);
			}

			// Normalize whitespace for curl commands (safe after PS detection)
			cmd = cmd.replace(/\s+/g, ' ').trim();

			// Remove 'curl' or 'curl.exe' from the beginning
			cmd = cmd.replace(/^curl(?:\.exe)?\s+/i, '');

			// Extract URL: try explicit --url flag first, then find the first
			// non-flag argument that looks like a URL (contains :// or starts with a known scheme)
			const explicitUrl = cmd.match(/(?:--url)\s+['"]?([^\s'"]+)['"]?/i);
			if (explicitUrl) {
				request.url = explicitUrl[1];
				cmd = cmd.replace(explicitUrl[0], '').trim();
			} else {
				// Tokenize and find the positional URL argument (skip flags and their values)
				const flagsWithArgs = /^(?:-[XHdouAeTbcDKm]|--request|--header|--data|--data-raw|--data-binary|--data-urlencode|--output|--user-agent|--user|--cookie|--connect-timeout|--max-time|--retry|--upload-file|--form|--resolve|--proxy|--cacert|--cert|--key|--referer|--write-out)$/i;
				const tokens = cmd.match(/(?:'[^']*'|"[^"]*"|\S+)/g) || [];
				let urlIndex = -1;
				for (let i = 0; i < tokens.length; i++) {
					const t = tokens[i].replace(/^['"]|['"]$/g, '');
					if (flagsWithArgs.test(t)) { i++; continue; } // skip flag + its value
					if (/^-/.test(t)) continue; // skip boolean flags like -v, -k, --compressed
					// This token is a positional argument — treat as URL
					request.url = t;
					urlIndex = i;
					break;
				}
				if (urlIndex !== -1) {
					tokens.splice(urlIndex, 1);
					cmd = tokens.join(' ');
				}
			}

			// Extract method (-X or --request)
			const methodMatch = cmd.match(/(?:-X|--request)\s+['"]?(\w+)['"]?/i);
			if (methodMatch) {
				request.method = methodMatch[1].toUpperCase();
			}

			// Extract headers (-H or --header)
			const headerRegex = /(?:-H|--header)\s+['"]([^'"]+)['"]/gi;
			let headerMatch;
			while ((headerMatch = headerRegex.exec(cmd)) !== null) {
				const [key, ...valueParts] = headerMatch[1].split(':');
				request.headers[key.trim()] = valueParts.join(':').trim();
			}

			// Extract data (-d or --data or --data-raw)
			const dataMatch = cmd.match(/(?:-d|--data|--data-raw)\s+['"](.+?)['"]/s) ||
				cmd.match(/(?:-d|--data|--data-raw)\s+\$'(.+?)'/s);
			if (dataMatch) {
				request.body = dataMatch[1];
			}

			return request;
		}

		async function sendRequest() {
			const curlCommand = curlInput.value.trim();

			if (!curlCommand) {
				output.value = 'Error: Please enter a cURL command';
				updateHighlight();
				status.textContent = '';
				return;
			}

			try {
				sendBtn.disabled = true;
				output.value = 'Sending request...';
				updateHighlight();
				status.textContent = 'Status: Processing...';

				const request = parseCurl(curlCommand);

				if (!request.url) {
					throw new Error('Could not parse URL from cURL command');
				}

				const startTime = Date.now();

				const fetchOptions = {
					method: request.method,
					headers: request.headers
				};

				if (request.body && request.method !== 'GET' && request.method !== 'HEAD') {
					fetchOptions.body = request.body;
				}

				const corsToggle = document.getElementById('corsToggle');
				const targetUrl = corsToggle.checked
					? 'https://corsproxy.io/?' + encodeURIComponent(request.url)
					: request.url;

				const response = await fetch(targetUrl, fetchOptions);
				const duration = Date.now() - startTime;

				const contentType = response.headers.get('content-type');
				let responseData;

				if (contentType && contentType.includes('application/json')) {
					responseData = await response.json();
					output.value = JSON.stringify(responseData, null, 2);
				} else {
					responseData = await response.text();
					output.value = responseData;
				}

				if (!response.ok) {
					const hint = {
						400: 'The request was malformed. Check your request body and parameters.',
						401: 'Authentication is required. Check your API key or credentials.',
						403: 'Access is forbidden. You may lack the required permissions.',
						404: 'The requested resource was not found. Verify the URL.',
						405: 'This HTTP method is not allowed for this endpoint.',
						408: 'The request timed out. Try again later.',
						429: 'Too many requests. You are being rate-limited. Wait and retry.',
						500: 'The server encountered an internal error.',
						502: 'Bad gateway. The upstream server returned an invalid response.',
						503: 'The service is temporarily unavailable. Try again later.',
						504: 'Gateway timeout. The upstream server did not respond in time.',
					}[response.status] || '';
					output.value = `⚠ HTTP ${response.status} — ${response.statusText}\n${hint ? hint + '\n' : ''}\n--- Server Response ---\n${output.value}`;
				}

				updateHighlight();

				status.textContent = `Status: ${response.status} ${response.statusText} | Time: ${duration}ms | Size: ${formatSize(output.value.length)}`;

			} catch (error) {
				let hint = '';
				if (error.message.includes('Failed to fetch')) {
					hint = '\n\nPossible causes:\n• The server is unreachable or the URL is incorrect\n• Network connection issue\n• CORS policy blocking the request';
				} else if (error.message.includes('NetworkError')) {
					hint = '\n\nA network error occurred. Check your connection and the target URL.';
				}
				output.value = `❌ Request Failed\n\n${error.message}${hint}`;
				updateHighlight();
				status.textContent = 'Status: Failed';
			} finally {
				sendBtn.disabled = false;
			}
		}

		function clearOutput() {
			output.value = '';
			outputHighlight.innerHTML = '';
			status.textContent = '';
			clearSearch();
		}

		function clearSearch() {
			searchMatches = [];
			currentMatchIndex = -1;
			searchInfo.textContent = '';
			searchInput.value = '';
			updateHighlight();
		}

		function escapeHtml(text) {
			return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
		}

		function escapeRegExp(string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		}

		function updateHighlight() {
			const text = output.value;
			const searchTerm = searchInput.value;

			if (!searchTerm || !text) {
				outputHighlight.innerHTML = escapeHtml(text);
				return;
			}

			const escapedTerm = escapeRegExp(searchTerm);
			const regex = new RegExp(escapedTerm, 'gi');
			let matchIdx = 0;
			const html = escapeHtml(text).replace(
				new RegExp(escapeRegExp(escapeHtml(searchTerm)), 'gi'),
				(match) => {
					const cls = matchIdx === currentMatchIndex ? 'current' : '';
					matchIdx++;
					return `<mark class="${cls}">${match}</mark>`;
				}
			);
			outputHighlight.innerHTML = html;
		}

		function searchInOutput() {
			const searchTerm = searchInput.value;
			const outputText = output.value;

			if (!searchTerm || !outputText) {
				searchMatches = [];
				currentMatchIndex = -1;
				searchInfo.textContent = '';
				updateHighlight();
				return;
			}

			// Create regex for case-insensitive contains search
			const escapedTerm = escapeRegExp(searchTerm);
			const regex = new RegExp(escapedTerm, 'gi');

			searchMatches = [];
			let match;

			// Find all matches and their positions
			while ((match = regex.exec(outputText)) !== null) {
				searchMatches.push({
					index: match.index,
					length: match[0].length
				});
			}

			if (searchMatches.length > 0) {
				currentMatchIndex = 0;
				updateHighlight();
				scrollToCurrentMatch();
				updateSearchInfo();
			} else {
				searchInfo.textContent = 'No matches';
				currentMatchIndex = -1;
				updateHighlight();
			}
		}

		function scrollToCurrentMatch() {
			const currentMark = outputHighlight.querySelector('mark.current');
			if (currentMark) {
				// Scroll the highlight div to the mark, then sync textarea
				currentMark.scrollIntoView({ block: 'center', behavior: 'smooth' });
				// Wait for smooth scroll to settle, then sync
				requestAnimationFrame(() => {
					output.scrollTop = outputHighlight.scrollTop;
				});
			}
		}

		function updateSearchInfo() {
			if (searchMatches.length > 0) {
				searchInfo.textContent = `${currentMatchIndex + 1} of ${searchMatches.length}`;
			} else {
				searchInfo.textContent = '';
			}
		}

		function nextMatch() {
			if (searchMatches.length === 0) return;
			currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
			updateHighlight();
			scrollToCurrentMatch();
			updateSearchInfo();
		}

		function previousMatch() {
			if (searchMatches.length === 0) return;
			currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
			updateHighlight();
			scrollToCurrentMatch();
			updateSearchInfo();
		}

		sendBtn.addEventListener('click', sendRequest);
		clearBtn.addEventListener('click', clearOutput);

		// Search functionality
		searchInput.addEventListener('input', searchInOutput);
		searchInput.addEventListener('keydown', (e) => {
			if (e.key === 'Enter') {
				if (e.shiftKey) {
					previousMatch();
				} else {
					nextMatch();
				}
			}
		});

		// Allow Ctrl/Cmd + Enter to send request
		curlInput.addEventListener('keydown', (e) => {
			if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
				sendRequest();
			}
		});
	</script>
</body>

</html>
